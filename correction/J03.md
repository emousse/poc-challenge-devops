# Correction du Challenge J3 - Continuous Deployment avec GitHub Actions

Voici une solution possible pour le Challenge E03, qui consiste √† mettre en place un pipeline de d√©ploiement continu pour une application frontend en utilisant GitHub Actions et Surge.sh.

## üìÇ Pr√©requis

*   Un projet frontend (ex: une application Vite, React, Vue) h√©berg√© sur GitHub.
*   Un compte Surge.sh et un token d'acc√®s.
*   Les secrets `SURGE_TOKEN` et `SURGE_DOMAIN` configur√©s dans les `Settings > Secrets and variables > Actions` de votre d√©p√¥t GitHub.

## üõ†Ô∏è √âtapes de la Solution

### 1. Configuration du Projet Frontend (Rappel)

Assurez-vous que votre projet frontend a les scripts n√©cessaires dans `package.json` :
*   `"build"`: pour g√©n√©rer les fichiers statiques de production (ex: `vite build`).
*   `(Optionnel) "test"`: pour ex√©cuter les tests (ex: `vitest run`).

### 2. Cr√©ation du Fichier de Workflow GitHub Actions

Cr√©ez le fichier `.github/workflows/deploy-frontend.yml` (ou le nom que vous avez choisi) √† la racine de votre projet :

```yaml
# .github/workflows/deploy-frontend.yml

name: Deploy Frontend to Surge.sh

# D√©clencheur : se lance √† chaque push sur la branche 'main'
on:
  push:
    branches:
      - main # Vous pouvez remplacer 'main' par le nom de votre branche principale (master, etc.)

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./projet/frontend  # Sp√©cifier le r√©pertoire de travail

    steps:
      # √âtape 1: R√©cup√©rer le code source du d√©p√¥t
      - name: Checkout code
        uses: actions/checkout@v4

      # √âtape 2: Mettre en place Node.js
      # Sp√©cifier la version de Node.js que votre projet utilise
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x' # Ou une autre version LTS comme 18.x
          cache: 'npm' # Activer le cache pour les d√©pendances npm pour acc√©l√©rer les builds futurs
          cache-dependency-path: projet/frontend/package-lock.json  # Chemin vers le lock file

      # √âtape 3: Installer les d√©pendances du projet
      # Utiliser 'npm ci' pour des installations plus rapides et plus fiables en CI
      - name: Install dependencies
        run: npm ci

      # √âtape 4: (Optionnel mais recommand√©) Ex√©cuter les tests
      # Cette √©tape √©chouera si les tests ne passent pas, arr√™tant le workflow avant le d√©ploiement.
      - name: Run tests
        run: npm test
        env:
          # Ajoutez vos variables d'environnement si n√©cessaire pour les tests
          REACT_APP_TEXT: "Test environment"

      # √âtape 5: Builder l'application frontend
      # La commande 'npm run build' devrait g√©n√©rer les fichiers statiques dans un dossier (ex: 'dist' ou 'build')
      - name: Build application
        run: npm run build
        env:
          # Variables d'environnement pour le build de production
          REACT_APP_TEXT: "Deployed from GitHub Actions"
          NODE_ENV: "production"

      # √âtape 6: D√©ployer sur Surge.sh
      - name: Deploy to Surge.sh
        run: |
          npm install --global surge # Installer Surge CLI dans l'environnement du runner
          surge --project ./dist --domain ${{ secrets.SURGE_DOMAIN }} --token ${{ secrets.SURGE_TOKEN }}
          # Assurez-vous que './dist' correspond bien au r√©pertoire de sortie de votre build.
          # Si votre build sort dans 'build/', utilisez '--project ./build'.
```

### 3. Explication du Workflow

*   **`name: Deploy Frontend to Surge.sh`**: Nom du workflow qui appara√Ætra dans l'onglet "Actions" de GitHub.
*   **`on: push: branches: [main]`**: D√©finit que le workflow se d√©clenchera √† chaque fois qu'un `push` est effectu√© sur la branche `main`.
*   **`jobs: build-and-deploy:`**: D√©finit un job nomm√© `build-and-deploy`.
*   **`runs-on: ubuntu-latest`**: Sp√©cifie que ce job s'ex√©cutera sur une machine virtuelle Ubuntu fournie par GitHub.
*   **`steps:`**: Liste les √©tapes s√©quentielles du job.
    *   **`actions/checkout@v4`**: Action officielle pour r√©cup√©rer le code de votre d√©p√¥t sur le runner.
    *   **`actions/setup-node@v4`**: Action officielle pour configurer l'environnement Node.js.
        *   `node-version: '20.x'`: Sp√©cifie la version majeure de Node.js.
        *   `cache: 'npm'`: Met en cache les d√©pendances `npm` pour acc√©l√©rer les builds suivants.
    *   **`npm ci`**: Installe les d√©pendances de mani√®re propre et rapide, en utilisant `package-lock.json`.
    *   **`npm run build`**: Ex√©cute le script de build de votre projet (d√©fini dans `package.json`).
    *   **`Deploy to Surge.sh`**:
        *   `npm install --global surge`: Installe la commande `surge` sur le runner.
        *   `surge --project ./dist --domain ${{ secrets.SURGE_DOMAIN }} --token ${{ secrets.SURGE_TOKEN }}`:
            *   `--project ./dist`: Indique √† Surge quel dossier d√©ployer (adaptez `dist` si votre projet build dans un autre dossier comme `build`).
            *   `--domain ${{ secrets.SURGE_DOMAIN }}`: Utilise le secret `SURGE_DOMAIN` pour sp√©cifier le domaine de destination.
            *   `--token ${{ secrets.SURGE_TOKEN }}`: Utilise le secret `SURGE_TOKEN` pour l'authentification.

### 4. Test du Workflow

1.  **Commitez et pushez les modifications :**
    *   Ajoutez le fichier `.github/workflows/deploy-frontend.yml` √† votre d√©p√¥t.
    *   Faites un commit et un push sur la branche `main`.
    ```bash
    git add .github/workflows/deploy-frontend.yml
    git commit -m "feat: Add GitHub Actions workflow for Surge.sh deployment"
    git push origin main
    ```
2.  **Observez l'ex√©cution sur GitHub :**
    *   Allez dans l'onglet "Actions" de votre d√©p√¥t GitHub.
    *   Vous devriez voir votre workflow "Deploy Frontend to Surge.sh" en cours d'ex√©cution ou termin√©.
    *   Cliquez sur le workflow, puis sur le job "Build and Deploy" pour voir les logs d√©taill√©s de chaque √©tape.
3.  **V√©rifiez le d√©ploiement :**
    *   Si toutes les √©tapes r√©ussissent, votre site frontend devrait √™tre d√©ploy√© et accessible √† l'URL que vous avez configur√©e dans `secrets.SURGE_DOMAIN`.

### 5. Solution pour le Bonus "D√©ploiement sur Pull Request Merg√©e"

Pour d√©clencher le d√©ploiement uniquement lorsqu'une Pull Request est merg√©e sur `main` :

```yaml
# .github/workflows/deploy-frontend.yml

name: Deploy Frontend to Surge.sh on PR Merge

on:
  pull_request:
    types: [closed] # Se d√©clenche quand une PR est ferm√©e (merg√©e ou non)
    branches:
      - main

jobs:
  build-and-deploy:
    # Condition pour s'assurer que la PR a bien √©t√© merg√©e
    if: github.event.pull_request.merged == true
    name: Build and Deploy
    runs-on: ubuntu-latest

    steps:
      # √âtape 1: R√©cup√©rer le code source du d√©p√¥t
      - name: Checkout code
        uses: actions/checkout@v4
        # Important: sur un √©v√©nement 'pull_request', checkout r√©cup√®re un commit de merge "test"
        # Pour r√©cup√©rer le code r√©ellement merg√© sur 'main', on peut sp√©cifier le SHA:
        # with:
        #   ref: ${{ github.event.pull_request.merge_commit_sha }}
        # Cependant, pour un build simple, le checkout par d√©faut sur l'event 'closed' PR est souvent suffisant si merg√© sur main.
        # Pour plus de certitude sur le code de 'main' apr√®s merge, on pourrait aussi d√©clencher sur 'push' vers 'main'
        # et s'assurer que seuls les merges de PR d√©clenchent le d√©ploiement (plus complexe √† filtrer).
        # L'approche ci-dessous est la plus simple pour "PR merg√©e".

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build

      - name: Deploy to Surge.sh
        run: |
          npm install --global surge
          surge --project ./dist --domain ${{ secrets.SURGE_DOMAIN }} --token ${{ secrets.SURGE_TOKEN }}
```
**Note sur le checkout pour PR merg√©e :**
Lors d'un √©v√©nement `pull_request` de type `closed` et `merged == true`, `actions/checkout` peut se comporter de mani√®re √† checker le "merge commit" potentiel. Pour s'assurer de builder le code tel qu'il est sur la branche `main` *apr√®s* le merge, il est parfois plus robuste de d√©clencher le d√©ploiement sur un `push` vers `main` et de s'assurer que ce `push` provient bien d'un merge de PR (par exemple, en inspectant le message de commit ou l'acteur). Cependant, la condition `if: github.event.pull_request.merged == true` sur l'√©v√©nement `pull_request closed` est la m√©thode la plus directe fournie par GitHub Actions pour ce cas d'usage.

## üîß Cas Particuliers

### Projets en Sous-dossier (Monorepo)

Si votre projet frontend est dans un sous-dossier (ex: `projet/frontend/`), ajoutez ces configurations :

```yaml
jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./projet/frontend  # Sp√©cifier le r√©pertoire de travail
    
    steps:
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          cache: 'npm'
          cache-dependency-path: projet/frontend/package-lock.json  # Chemin vers le lock file
```

### Variables d'Environnement

Si votre application utilise des variables d'environnement (fichier `.env`), vous devez les d√©finir dans le workflow :

**Option 1: Variables inline (pour des valeurs non-sensibles)**
```yaml
- name: Build application
  run: npm run build
  env:
    REACT_APP_TEXT: "Deployed from GitHub Actions"
    REACT_APP_ENVIRONMENT: "production"
```

**Option 2: Secrets GitHub (pour des valeurs sensibles)**
```yaml
- name: Build application
  run: npm run build
  env:
    REACT_APP_API_KEY: ${{ secrets.REACT_APP_API_KEY }}
    REACT_APP_DATABASE_URL: ${{ secrets.REACT_APP_DATABASE_URL }}
```

### Gestionnaire de Paquets

**Pour pnpm :**
```yaml
- name: Setup Node.js
  uses: actions/setup-node@v4
  with:
    node-version: '20.x'
    cache: 'pnpm'
    cache-dependency-path: pnpm-lock.yaml

- name: Install pnpm
  run: npm install -g pnpm

- name: Install dependencies
  run: pnpm install --frozen-lockfile
```

**Pour yarn :**
```yaml
- name: Setup Node.js
  uses: actions/setup-node@v4
  with:
    node-version: '20.x'
    cache: 'yarn'

- name: Install dependencies
  run: yarn install --frozen-lockfile
```

## üö® D√©pannage

### Erreurs Courantes

**Erreur : "Dependencies lock file is not found"**
- V√©rifiez que `package-lock.json` existe dans votre projet
- Si vous utilisez pnpm, g√©n√©rez un `package-lock.json` avec `npm install`
- Sp√©cifiez le bon chemin avec `cache-dependency-path`

**Erreur : "Environment variable is undefined"**
- Ajoutez les variables d'environnement manquantes dans les sections `env:` des √©tapes concern√©es
- V√©rifiez que vos secrets GitHub sont bien configur√©s

**Erreur : "ENOENT: no such file or directory './dist'"**
- V√©rifiez le r√©pertoire de sortie de votre build (peut √™tre `build` au lieu de `dist`)
- Adaptez la commande surge : `--project ./build` si n√©cessaire

**Erreur : "surge: command not found"**
- Assurez-vous d'installer surge globalement : `npm install --global surge`

### Tests de D√©bogage

1. **Tester le workflow manuellement :**
   - Ajoutez `workflow_dispatch:` dans les d√©clencheurs
   - Utilisez l'onglet Actions > "Run workflow"

2. **V√©rifier les logs :**
   - Consultez les logs d√©taill√©s dans l'onglet Actions
   - Chaque √©tape affiche ses erreurs sp√©cifiques

3. **Tester localement :**
   ```bash
   npm ci
   npm test
   npm run build
   ls dist/  # V√©rifier que les fichiers sont g√©n√©r√©s
   ```
