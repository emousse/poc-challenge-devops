# Saison DevOps - √âpisode 4 : Challenge - Ready to Prod! Images DockerHub & Simulation MEP

F√©licitations, vous √™tes arriv√©s au dernier challenge de cette saison DevOps ! Apr√®s avoir automatis√© le d√©ploiement de notre frontend, nous allons maintenant pr√©parer nos applications (frontend et backend) pour une mise en production plus robuste en cr√©ant des images Docker standardis√©es, en les publiant sur DockerHub, puis en simulant un d√©ploiement de "production" avec Docker Compose.

## üéØ Objectifs P√©dagogiques

*   **Comprendre** les concepts de base de la pr√©paration √† la mise en production (Ops).
*   **Cr√©er** des images Docker optimis√©es pour le frontend et le backend.
*   **Publier** ces images sur DockerHub en utilisant un pipeline GitHub Actions.
*   **Utiliser** des actions Docker sp√©cifiques (ex: `docker/setup-buildx-action`, `docker/login-action`, `docker/metadata-action`, `docker/build-push-action`).
*   **Simuler** une mise en production en utilisant Docker Compose avec les images pr√©c√©demment publi√©es sur DockerHub.

## üìã Contexte du Projet

*   **Votre application frontend dockeris√©e :** Issue des challenges pr√©c√©dents, avec son `Dockerfile`.
*   **Votre application backend dockeris√©e :** Issue des challenges pr√©c√©dents, avec son `Dockerfile`.
*   **Un compte DockerHub :** N√©cessaire pour publier vos images.
*   **Votre d√©p√¥t GitHub :** Pour h√©berger le code et configurer GitHub Actions.

## üöÄ Votre Mission

### Partie 1 : Publication des Images sur DockerHub via GitHub Actions

1.  **Pr√©paration des `Dockerfile` (Optimisation) :**
    *   Revoyez les `Dockerfile` de votre frontend et de votre backend. Assurez-vous qu'ils sont optimis√©s pour la production (ex: utilisation de multi-stage builds, `npm ci --omit=dev` ou √©quivalent, `ENV NODE_ENV=production`, images de base l√©g√®res).

2.  **Configuration des Secrets GitHub :**
    Dans votre d√©p√¥t GitHub (`Settings > Secrets and variables > Actions`), assurez-vous d'avoir les secrets suivants (ou cr√©ez-les) :
    *   `DOCKERHUB_USERNAME` : Votre nom d'utilisateur DockerHub.
    *   `DOCKERHUB_TOKEN` : Un Access Token DockerHub avec les permissions Read, Write, Delete. (Ne pas utiliser votre mot de passe DockerHub directement).

3.  **Cr√©ation du Workflow GitHub Actions (`.github/workflows/publish-images.yml`) :**
    Ce workflow devra :
    *   **Se d√©clencher (`on`) :** Lorsqu'une Pull Request est ferm√©e ET merg√©e sur la branche `main`.
    *   **Avoir deux jobs parall√®les** (ou s√©quentiels si vous pr√©f√©rez, mais parall√®les est plus efficace) :
        *   **Un Job pour le Frontend (`build-and-push-frontend`) :**
            1.  R√©cup√©rer le code (`actions/checkout`).
            2.  Mettre en place Docker Buildx (`docker/setup-buildx-action`).
            3.  Se connecter √† Docker Hub (`docker/login-action`) en utilisant les secrets.
            4.  Extraire les m√©tadonn√©es pour l'image Docker (`docker/metadata-action`).
                *   Nom de l'image : `<VOTRE_DOCKERHUB_USERNAME>/<nom-frontend-app>`.
                *   Tags sugg√©r√©s : `latest`, version s√©mantique (si vous taguez vos releases Git, ex: `v1.2.3`), SHA du commit.
            5.  Builder l'image Docker du frontend (√† partir de son `Dockerfile`) et la pusher sur DockerHub en utilisant `docker/build-push-action` avec les tags et labels g√©n√©r√©s.
        *   **Un Job pour le Backend (`build-and-push-backend`) :**
            1.  √âtapes similaires au job frontend, mais pour l'application backend.
            2.  Nom de l'image : `<VOTRE_DOCKERHUB_USERNAME>/<nom-backend-app>`.

### Partie 2 : Simulation d'une Mise en Production avec Docker Compose (Bonus)

Cette partie est un bonus, mais fortement recommand√©e pour comprendre le cycle complet.

1.  **Cr√©er un Fichier `docker-compose.prod.yml` :**
    *   Ce fichier d√©crira votre stack "de production" simul√©e.
    *   Il devra utiliser les images du **frontend** et du **backend** que vous venez de publier sur **DockerHub** (ne pas utiliser `build:` ici).
        *   Exemple : `image: VOTRE_DOCKERHUB_USERNAME/nom-frontend-app:latest` (ou un tag plus sp√©cifique).
    *   Incluez √©galement les autres services n√©cessaires, configur√©s pour un environnement de type production :
        *   Un service de **base de donn√©es** (ex: `postgres`), avec persistance des donn√©es et variables d'environnement pour la production.
        *   Un service **Caddy** (ou un autre reverse proxy) pour exposer vos applications, en utilisant un `Caddyfile.prod` distinct si n√©cessaire.
    *   Configurez des politiques de red√©marrage appropri√©es pour vos services (ex: `restart: unless-stopped`).

2.  **Tester le Compose de Production en Local :**
    *   Ex√©cutez `docker compose -f docker-compose.prod.yml up -d`.
    *   V√©rifiez que tous les services d√©marrent et que l'application est accessible et fonctionne comme attendu, en utilisant les images tir√©es de DockerHub.

## ‚ú® Crit√®res de Succ√®s

*   Les `Dockerfile` du frontend et du backend sont optimis√©s pour la production.
*   Les secrets `DOCKERHUB_USERNAME` et `DOCKERHUB_TOKEN` sont correctement configur√©s.
*   Le workflow GitHub Actions (`publish-images.yml`) se d√©clenche correctement lors du merge d'une PR sur `main`.
*   Les deux jobs (frontend et backend) du workflow r√©ussissent :
    *   Les images sont build√©es.
    *   Les images sont correctement tagu√©es (ex: `latest`, et d'autres tags comme le SHA ou la version).
    *   Les images sont push√©es sur votre compte DockerHub.
*   Vous pouvez v√©rifier la pr√©sence des images et de leurs tags sur le site de DockerHub.
*   **(Bonus)** Le fichier `docker-compose.prod.yml` lance correctement l'application en utilisant les images de DockerHub.
*   **(Bonus)** L'application simul√©e en "production" est fonctionnelle.

## üí° Conseils

*   Pour `docker/metadata-action`, explorez les diff√©rentes options de `tags` pour g√©n√©rer automatiquement des versions d'images pertinentes. Par exemple, pour taguer avec la version s√©mantique d'un tag Git :
    ```yaml
    # Dans docker/metadata-action
    tags: |
      type=semver,pattern={{version}} # Si vous avez des tags Git comme v1.0.0
      type=semver,pattern={{major}}.{{minor}}
      type=sha # Tag avec le hash du commit
      type=raw,value=latest,enable={{is_default_branch}} # 'latest' uniquement pour la branche par d√©faut
    ```
*   Pour la partie bonus `docker-compose.prod.yml`, veillez √† bien nommer vos services et volumes pour √©viter les conflits si vous avez aussi un `docker-compose.yml` de d√©veloppement.
*   N'oubliez pas le fichier `.dockerignore` pour chaque application afin d'optimiser le contexte de build envoy√© au d√©mon Docker.

Pr√©parez vos applications pour le grand public !