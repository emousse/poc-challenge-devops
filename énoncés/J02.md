# Dockerisation back et reverse proxy

F√©licitations pour avoir termin√© le premier challenge ! Nous allons maintenant complexifier notre application en ajoutant un service backend et en mettant en place un reverse proxy pour g√©rer l'acc√®s √† nos diff√©rents services de mani√®re plus professionnelle.

Ce challenge part du principe que vous avez une application fonctionnelle avec un frontend et une base de donn√©es PostgreSQL dockeris√©s, ainsi qu'Adminer (solution du Challenge E01).

## üéØ Objectifs P√©dagogiques

*   **Appliquer** les commandes Docker pour la construction d'une image backend.
*   **√âvaluer** la construction d'une image Docker optimis√©e (penser aux multi-stage builds si pertinent).
*   **Int√©grer** un nouveau service backend dans une architecture Docker Compose existante.
*   **Comprendre** le fonctionnement et l'utilit√© d'un reverse proxy.
*   **Mettre en ≈ìuvre** un reverse proxy (Caddy) pour router les requ√™tes vers les services appropri√©s via des sous-domaines.

## üöÄ Votre Mission

1.  **Dockeriser le Backend (`backend`) :**
    *   Cr√©ez un `Dockerfile` pour votre application backend.
        *   Utilisez une image de base Node.js l√©g√®re (ex: `node:XX-alpine`).
        *   Le `Dockerfile` doit copier le code source, installer les d√©pendances (`npm install --omit=dev` pour la production), et d√©finir la commande pour d√©marrer le serveur backend (ex: `npm start`).
        *   Pensez √† `ENV NODE_ENV=production`.
    *   Int√©grez ce nouveau service `backend` dans votre fichier `docker-compose.yml` existant.
        *   Le backend n'a **pas** besoin d'exposer de port directement √† la machine h√¥te dans cette √©tape, car le reverse proxy s'en chargera.
        *   Assurez-vous qu'il puisse communiquer avec la base de donn√©es `db` si n√©cessaire (m√™me si l'exemple ci-dessus ne le fait pas activement).

2.  **Mettre en place un Reverse Proxy avec Caddy (`caddy`) :**
    *   Ajoutez un service `caddy` √† votre `docker-compose.yml` en utilisant l'image officielle `caddy`.
    *   Cr√©ez un fichier `Caddyfile` √† la racine de votre projet.
    *   Configurez Caddy pour qu'il agisse comme reverse proxy pour vos services :
        *   **Frontend :** Accessible via `http://localhost` (ou `http://app.localhost` si vous pr√©f√©rez).
        *   **Backend :** Accessible via `http://api.localhost`.
        *   **Adminer :** Accessible via `http://adminer.localhost`.
    *   Le service `caddy` sera le **seul** service √† exposer les ports `80` (et `443` si vous souhaitez exp√©rimenter avec HTTPS, bien que non requis pour ce challenge) √† la machine h√¥te.
    *   Les services `frontend`, `backend`, et `adminer` ne devront plus avoir de section `ports` dans `docker-compose.yml` (sauf si vous voulez garder un acc√®s direct pour le d√©bogage, mais l'objectif est d'utiliser Caddy).

3.  **Modifier la configuration du Frontend (si n√©cessaire) :**
    *   Si votre frontend doit appeler le backend, assurez-vous qu'il utilise la nouvelle URL fournie par le reverse proxy (ex: `http://api.localhost/api/hello`) au lieu d'une URL comme `http://localhost:BACKEND_PORT_DIRECT`. Cela peut n√©cessiter de passer une variable d'environnement √† votre conteneur frontend.

## ‚úÖ Checklist

- [ ] Un `Dockerfile` fonctionnel pour le service backend.
- [ ] Le fichier `docker-compose.yml` mis √† jour orchestre les **quatre services** : frontend, backend, db, caddy, adminer.
- [ ] **Caddy** est le seul service exposant directement des ports √† l'h√¥te (typiquement le port 80).
- [ ] Le frontend est accessible via `http://localhost` (ou `http://app.localhost`) et fonctionne.
- [ ] L'API backend est accessible via `http://api.localhost` (ex: `http://api.localhost/api/hello`).
- [ ] Adminer est accessible via `http://adminer.localhost` et peut toujours se connecter √† la base de donn√©es `db`.
- [ ] Tous les services d√©marrent correctement avec `docker compose up -d`.
- [ ] Les logs des conteneurs sont propres (pas d'erreurs bloquantes).
- [ ] Le fichier `hosts` local (`/etc/hosts` ou `C:\Windows\System32\drivers\etc\hosts`) contient bien‚ÄØ:
    ```
    127.0.0.1 localhost
    127.0.0.1 api.localhost
    127.0.0.1 adminer.localhost
    # 127.0.0.1 app.localhost
    ```

## üéÅ Bonus

*   Utiliser des variables d'environnement dans votre `docker-compose.yml` ou via un fichier `.env` pour :
    *   Choisir la version des images Docker utilis√©es (ex: `POSTGRES_VERSION=15-alpine`).
    *   Personnaliser les noms des sous-domaines dans le `Caddyfile` (n√©cessite une astuce, car Caddy ne fait pas de substitution d'env simple dans les noms de sites du Caddyfile directement, mais vous pouvez utiliser des variables d'environnement pour *√† l'int√©rieur* des directives `reverse_proxy` ou pour g√©n√©rer le Caddyfile).
*   Faire en sorte que votre application frontend appelle dynamiquement une route de votre backend (ex: `/api/hello`) et affiche la r√©ponse.

Bonne conteneurisation et bon routage !
